복습
반복문 조건문 : 제어문
배열 >> 자료형, 크기, 관련성
	String[] datas = new String[10];
	datas[0] = "사과";
	Student[] datas = new Student[5];
class
기본 생성자 >>> 생성자를 1개라도 선언했다면 사라짐
this.xxx
생성자 == "멤버변수 초기화" 역할
static -> "객체와 무관하게" == 멤버변수x 클래스 소속 o 공유자원!

부모-자식  자식 클래스의 모든 생성자는 부모의 기본생성자를 가장 먼저 호출
	super();
	부모의 기본생성자가 없다면?
		부모의 다른 생성자를 사용!
부모의 메서드의 기능이 마음에 들지 않을 때
	--> 메서드 재정의 == 오버라이딩
		vs 함수명 중복 정의 허용 == 오버로딩
	모든 클래스들은 toString()을 오버라이딩 쓸 수 있는데
	JAVA의 최상위클래스 Object가 존재하기 때문 --> toString() 제공

	동적바인딩 -> 다형성을 실현

----------------------------------------------
캡술화와 추상화

[캡술화]
 기능을 단위별로(클래스별로) ==> 모듈화, 컴포넌트화
보관하는 java의 특성 덕분에, 구현에 필요한 기능이 있다면 이미 만들어진 것을 가져오면 된다는 내용
	import

 내가 사용하는 클래스, 패키지, 코드 덩어리들 ... 내용을 몰라도 
"사용방법(용법, 언제 쓰는지)"만 알면 쉽게 가져다가 사용할 수 있다!

내가 개발한 내용을 상대방이 몰라도 쓸 수 있게 묶어서 배포
 == 정보은닉(hiding)
그래서 함수명이 쉬워야하고, 인자와 아웃풋이 그럴듯해야함

int plus(int[] datas)
boolean isEmpty(int[] datas, int cnt)
메서드 시그니쳐만 보고도 다른 사람들이 쉽게 이해할 수 있어야함
나만 아는 단어 x, 너무 줄여도 x
input, output 너무 중요함 ==> 설계에서 정함

-----------
메인이라는 공간에서 홍길동의 점수를 바꿀 수 있다?
개발자가 임의로 데이터값을 언제든지 수정할 수 있다는 뜻
모든 데이터 값은 "함수, 메서드"를 통해서 변경해야만 한다!
 => 로그(기록)이 남기 때문에
 => 연산자는 남지 않는다.

그래서 클래스 외부에서 멤버변수에 접근하는 것을 막아야함
JAVA는 공개정책이라 하나하나 다 닫아줘야한다.
"접근 제어자"를 사용해서 공개범위를 변경

private 된 멤버변수의 값을 변경하려면
반드시 메서드를 거쳐야한다.

멤버 변수에 값을 넣을 때는  set멤버변수명()
	값을 넣는 것이라 input(인자)만 있음
멤버 변수의 값을 받아올 때는 get멤버변수명()
	값을 받아오는 것이라 output밖에 없음

게터세터
멤버변수 수만큼 모두 만들어야 함
코드 내에 어디서든 호출 될 수 있어야 하므로
	=> public
java가 자동으로 만들어줌
source>> Generate Getter and Setter

캡슐화 정리
모든 멤버변수 앞에는 private을 붙임
	외부 접근을 제한하기 위함
그래서 getter, setter를 반드시 추가해야함
	호출되어야하기 때문에 public

private는 자식 클래스도 접근 x
자식 클래스한테는 오픈해줘 => protected

protected
자식 클래스까지만 오픈

private는 멤버변수에만 사용하고,
클래스 변수는 객체가 아닌 클래스 이름으로 불러야 한다.
	ex) Circle 클래스
		객체명.PI (x) --> Circle.PI


------------------------------------------------------------------
[추상화]

java 웹 개발을 하다보면 java가 아닌 언어를 사용하 확률이 점점 높아진다.
JAVA를 기반으로 한 회사마다 새로운 언어 or 프레임워크가 있다.

그 회사에서만 사용하는 언어(or 기술)!
JAVA만 공부하면, 다른 언어를 만났을 때 "안배워서 모르는데요"
			옳지 않다.

세상 모든 java 기반 언어들이 공통으로 하는 모토(기준)이 "추상화" 개념을 반드시 가지고 있다.

 지금 당장은 잘 안 쓰지만
 >> 세상 모든 언어들이 이 "추상화"개념을 바탕으로 뭔가를 한다는 점★


추상화의 역사
ex) 하트 클래스를 만드려면
1. 카피하려고 기존의 것들을 살펴본다. -> 일치하지 않는다.
2. 내가 만드려는 클래스가
   기존의 클래스들의 하위가 아니라,
   기존 클래스 급이라서 그런다.
3. 복사하면 안 된다.
4. 기존 클래스들의 상위 개념이 있구나
	== 기존 클래스들의 상위 개념이 있구나
	== 기존 클래스들에게 공통점이 있구나
5. 형체없이, 기존 클래스들의 공통점을 뽑아냄
	== 추상 클래스(기존 클래스들의 상위 클래스)
  => 객체화 x
  => 클래스들을 정의하는데에 활용함

클래스들의 틀(추상 클래스) ----> 클래스 ----> 객체를 뽑아내려고

초기 JAVA는 여러 개의 국가에서 동시 개발을 했음
네모	세모	원  ---> 어? 공통점이 있네
			===> 뽑아내자!
			추상 클래스 "abstract"
	객체화 x, 클래스들을 정의(클래스들의 틀)하는데 의의

ex) 포켓몬 포켓몬 = new 포켓몬(); xxxx : 포켓몬이라는 포켓몬은 없음
     피카츄 클래스에서 피카츄 여러마리 생성 가능
     메타몽 여러마리

     동물과 강아지, 고양이, 나비 등등도 포켓몬과 같은 관계

abstract 추상 클래스
추상 클래스는 객체화를 못함


추상 클래스에서
자기 자식들 클래스에게
 특정 메서드를 오버라이딩하라고 '강제'하고 싶은 상황
오버라이딩을 강제하는 문법이 필요하다
	>> 강제는 개발자에게 좋은 의미
	>> 실수를 줄여주니까

abstract 추상 메소드
abstract이 붙은 메소드를 말한다
"오버라이딩 강제"하는 역할
기능의 내용이 없기 때문에 {}메서드 바디가 필요없음

추상 메소드가 한 개 이상 있으려면 해당 클래스가 반드시 추상 클래스가 되어야한다.

생성자에 public 붙이면 좋다.

---------------------------------------------------------
인터페이스
추상클래스 + 인터페이스 (같이 다님)
중요도는 인터페이스가 더 높다.

같은 기능을 수행하는 메서드들끼리 이름이나 인자, 리턴이 다르면 구현이 불편함
	== 유지보수가 불리함

개발자의 제 1목표
	== 유지보수 용이 극대화

=> 같은 기능을 수행하는 메서들끼리 이름이나 인자, 리턴이 같아야함
	==메서드 시그니쳐를 "강제"해야할 필요성이 있다.
  => 오버라이딩을 강제해야한다!

근데 상속관계가 아닐 때가 있음
 "인터페이스"를 활용

인터페이스는 한 프로그램 안에 쓸 수 있음
그 경우 public은 빼고 작성









